\documentclass{scrreprt}

\usepackage{xcolor} % for different colour comments
\usepackage{tabto}
\usepackage{mdframed}
\mdfsetup{nobreak=true}
\usepackage{xkeyval}
\usepackage{tabularx}
\usepackage{booktabs}
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=red,
    urlcolor=blue
}
\usepackage[skip=2pt, labelfont=bf]{caption}
\usepackage{titlesec}
\usepackage{graphicx}
\usepackage[section]{placeins}
\graphicspath{ {image/} }

\titleformat{\paragraph}
{\normalfont\normalsize\bfseries}{\theparagraph}{1em}{}
\titlespacing*{\paragraph}
{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}


%% Comments
\newif\ifcomments\commentstrue

\ifcomments
\newcommand{\authornote}[3]{\textcolor{#1}{[#3 ---#2]}}
\newcommand{\todo}[1]{\textcolor{red}{[TODO: #1]}}
\else
\newcommand{\authornote}[3]{}
\newcommand{\todo}[1]{}
\fi

\newcommand{\wss}[1]{\authornote{magenta}{SS}{#1}}
\newcommand{\ds}[1]{\authornote{blue}{DS}{#1}}


%% The following are used for pretty printing of events and requirements
\makeatletter

\define@cmdkey      [TP] {test}     {name}       {}
\define@cmdkey      [TP] {test}     {desc}       {}
\define@cmdkey      [TP] {test}     {type}       {}
\define@cmdkey      [TP] {test}     {init}       {}
\define@cmdkey      [TP] {test}     {input}      {}
\define@cmdkey      [TP] {test}     {output}     {}
\define@cmdkey      [TP] {test}     {pass}       {}
\define@cmdkey      [TP] {test}     {user}       {}
\define@cmdkey      [TP] {test}     {reqnum}     {}


\newcommand{\getCurrentSectionNumber}{%
  \ifnum\c@section=0 %
  \thechapter
  \else
  \ifnum\c@subsection=0 %
  \thesection
  \else
  \ifnum\c@subsubsection=0 %
  \thesubsection
  \else
  \thesubsubsection
  \fi
  \fi
  \fi
}

\newcounter{TestNum}

\@addtoreset{TestNum}{section}
\@addtoreset{TestNum}{subsection}
\@addtoreset{TestNum}{subsubsection}

\newcommand{\testauto}[1]{
\setkeys[TP]{test}{#1}
\refstepcounter{TestNum}
\begin{mdframed}[linewidth=1pt]
\begin{tabularx}{\textwidth}{@{}p{3cm}X@{}}
{\bf Test \getCurrentSectionNumber.\theTestNum:} & {\bf \cmdTP@test@name}\\[\baselineskip]
{\bf Description:} & \cmdTP@test@desc\\[0.5\baselineskip]
{\bf Type:} & \cmdTP@test@type\\[0.5\baselineskip]
{\bf Initial State:} & \cmdTP@test@init\\[0.5\baselineskip]
{\bf Input:} & \cmdTP@test@input\\[0.5\baselineskip]
{\bf Output:} & \cmdTP@test@output\\[0.5\baselineskip]
{\bf Pass:} & \cmdTP@test@pass\\[0.5\baselineskip]
{\bf Req. \#:} & \cmdTP@test@reqnum
\end{tabularx}
\end{mdframed}
}

\newcommand{\testmanual}[1]{
\setkeys[TP]{test}{#1}
\refstepcounter{TestNum}
\begin{mdframed}[linewidth=1pt]
\begin{tabularx}{\textwidth}{@{}p{3cm}X@{}}
{\bf Test \getCurrentSectionNumber.\theTestNum:} & {\bf \cmdTP@test@name}\\[\baselineskip]
{\bf Description:} & \cmdTP@test@desc\\[0.5\baselineskip]
{\bf Type:} & \cmdTP@test@type\\[0.5\baselineskip]
{\bf Testers:} & \cmdTP@test@user\\[0.5\baselineskip]
{\bf Pass:} & \cmdTP@test@pass\\[0.5\baselineskip]
{\bf Req. \#:} & \cmdTP@test@reqnum
\end{tabularx}
\end{mdframed}
}

\makeatother

\newcommand{\ZtoT}{
\begin{tabularx}{3.85cm}{@{}p{0.35cm}p{0.35cm}p{0.35cm}p{0.35cm}p{0.35cm}p{0.35cm}p{0.35cm}p{0.35cm}p{0.35cm}p{0.35cm}p{0.35cm}@{}}
0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10
\end{tabularx}
}

\begin{document}
\title{\bf Text to Motion Database\\[\baselineskip]\Large Design Document}
\author{Brendan Duke\\Andrew Kohnen\\Udip Patel\\David Pitkanen\\Jordan Viveiros}
\date{\today}

\maketitle

\pagenumbering{roman}
\tableofcontents
% \listoftables
% \listoffigures


\begin{table}[bp]
\caption*{\bf Revision History}
\begin{tabularx}{\textwidth}{p{3.5cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
January 5, 2017 & 0.0 & File created\\
\bottomrule
\end{tabularx}
\end{table}

\newpage

\pagenumbering{arabic}

\chapter{Overview}
The Text to Motion Database aims to provide a living database of pose estimated media with word pairings and tags. The purpose of this document is to provide a detailed description of the design choices for each section of the Text to Motion Database.

\chapter{User Experience}
A user experience is the overall journey of a person on the Text to Motion Database with respects to the learnability and usability. This section is organized to describe the journey between web pages and any design choices that went into the user interface in order to improve the overall experience.

\begin{figure}[!ht]
        \caption{McMaster Text-to-Motion Database User Experience}
        \label{userExp}
        \centering
        \includegraphics[width=0.8\textwidth]{../Docs/data/UserExperience.png}
\end{figure}

\section{User Journey}
As seen in the Figure above when a user comes to the Text to Motion Database they will see the home page. At first glance they see some information about the website and how it can be used along with some different page options located at the top. Each of these different pages displays something different and is hinted at within the name of the page; with ImagePoseDraw being the most ambiguous. All the pages can be accessed by an anonymous user but in order to upload media a user must register or sign in. Each page will be described in greater detail below with additional functionality and design choices.

\section{Home Page}
As previously mentioned the first page seen on the Text to Motion Database is the home page, it contains an application description, resources that were used, and brief instructions on how to use the website. The overall design of the page was to be simple and present the information to the user front and center so that they could explore the options given to them on their own.

\section{About}
The about page is a more granular description of the Text to Motion Database’s overview, problem statement and what the intended use of the website is. Like the home page a simple design and colour scheme was chosen along with plain text for easier reading.

\section{Contact}
The contact page maintains the overall look and feel of the website with plain text and induvial boxes for the contact information of each group member and supervisors. Every box contains the member’s name, and email at minimum with the addition of titles for each supervisor and the department for each group member.

\section{Navigation Bar}
In order to maintain an easy way to navigate the website the navigation bar located at the top of the page contains links to each page with fixed locations. This allows the users to learn the link location and makes for a more enjoyable experience.

\section{Log In}
If the user has already made an account with the Text to Motion Database they can use the login page to access the account in order to upload images and video. While on the login page before successfully logging in the page location on the navigation bar is in the far right corner, and after logging in is replaced by the option to log off.
From a design standpoint the login page contains two text boxes for entry, an option for the username to be remembered, a login button, and hyperlinks to register or recover a lost password. Overall it is a very standard login screen and should help a first time user navigate through without any confusion or misunderstanding.

\section{Register}
If the user has not already made an account and wishes to do so the option to register can be accessed from the navigation bar or the login page. It follows the same website standards that the login page does and has three text boxes for a username, password and password confirmation along with the button to complete a registration. Once a user has made and account or successfully logged in the register option in the navigation bar will be replaced by a greeting and take them to the account management options which at revision 0 are not fully complete.

\section{Text To Motion}
Searching the database is not restricted by the users account and can be accessed by anyone since it is one of the core features of the Text to Motion Database. The ability to search through the pose estimated data is done through the large search bar on the page, helping the user focus on it in order to explain the pages functionality.

\subsection{Search Results}
Once the search bar has received input it will parse through the database to return uploads that match or have strong resemblance of the input in a column format. Each result will take the user to a separate page with the Name, Description and pose estimated media. The layout of the results shows the user what was returned without any additional information to promote the usability and accuracy of the search.

\section{Image Pose Draw}
Once the user has navigated to the page labeled ImagePoseDraw the initial view is that of a table with names, descriptions and hyperlinks. This is currently where the most recent uploads are displayed with the name and description that were given during the uploading process. The table is designed to separate each upload through a dark and light shading in order to easy distinguish two different entries. Beyond the table the page has two other key functions in the ability to search through the table with by the name or description, and create new pose estimated uploads through the hyperlink above the table.

\subsection{Create}
If the option to create a new entry has been selected the user is taken to a new page where they have the ability to upload a new image in order to be pose estimated and stored within the database. Choosing the image to upload can be done from a URL or internal storage and opens a file explorer when selected. After an image has been picked the user has to provide a name and description to the image before it has been pose estimated to be stored in the database and provide a search option. Upon completion of the above steps the image can be uploaded, taking the user back to the ImagePoseDraw page with the new entry after the processing has happened.

\subsection{Description}
In order to see the uploaded media the user can use the name associated with an image to find it by searching or scrolling through alphabetically. After the upload is located the user can edit the tags of the image, delete the image and tags, or view the pose estimated media. Deciding to edit the upload takes them to a new screen where the options to change the name or description that was previously input are given. As of revision 0 if the user wants to remove or change their uploaded image they have to first delete the previous entry using the Delete option and go through the steps of creating again. If the user wants to view the selected entry the details option will take them to a new page to view this.

\subsection{Details}
On the details page the user can see the name and description that was chosen at the time of the upload and the image that was been pose estimated to show the chin, and upper arms. Each section of the image is clearly defined with the chin and joints being represented by red circles and the upper arms being represented by two green lines connected at a joint. This shows the user where the algorithm believes the labeled sections are and the separation of colour allows for an easy understanding of the positioning.

\chapter{Database Structure}

\section{Database Schema}
The Figure below shows an entity relationship diagram for the current itteration of the database schema.

\begin{figure}[!ht]
        \caption{Database Entity-Relationship Diagram}
        \label{erDiagram}
        \centering
        \includegraphics[width=0.8\textwidth]{../data/ER-Diagram.png}
\end{figure}

\section{Table Description}

\chapter{Module Decomposition}

\section{Text To Motion - ASP.NET Application}


\subsection{Overview}
This component of the application is used to display the web interface and responsible for linking the database and pose estimation. In order to perform these tasks 'ASP.net' and the Model, View, Controller (MVC) structure is utilized. A general description of additions or customizations to the 'ASP.net' code along with the argument types, models used, and view output will be outlined below.

\subsection{Models}
Two Models were added to the given code from 'ASP.net' in order to store data on the image that has been pose estimated and any account information specific to a user.

    \begin{itemize}
      \item \textbf  ApplicationUsers
      The ApplicationUsers model will be used to add profile data to application, but is currently empty as there are no properties being stored.

      \item \textbf  PoseDrawnImage
      PoseDrawnImage uses the {get; set;} property to store the ID, Description and Name for a given image.
        int ID
        string Name
        string Description

    \end{itemize}

\subsection{HomeController}
The HomeController is a simple controller that is used to display the Index, About and Contact pages.

  \textbf Function: Index()
  \begin{itemize}
    \item Expected Arguments:
    NA
    \item Returns:
    The view of Index.cshtml.
    \item Description:
    Calls the View of Index through the MVC, in order to display the ImagePoseDraw.
  \end{itemize}

  \textbf Function: About()
  \begin{itemize}
    \item Expected Arguments:
    NA
    \item Returns:
    The view of About.cshtml.
    \item Description:
    Calls the View of About in order to display the About page.
  \end{itemize}

  \textbf Function: Contact()
  \begin{itemize}
    \item Expected Arguments:
    NA
    \item Returns:
    The view of Contact.cshtml.
    \item Description:
    Calls the View of Contacts in order to display the Contact information.
  \end{itemize}

\subsection{AccountController}
The AccountController is used in order to verify Register and Login information for a user, using the HTTP Get and Post. It utilizes built in functions of 'ASP.net' but a majority are not being used for revision 0, so they are omitted below.

  \textbf Function:  HTTP[Get] Login(args)
  \begin{itemize}
    \item Expected Arguments:
    string returnUrl = null;
    \item Returns:
    The View of Login.cshtml.
    \item Description:
    Displays the Login page and stores the ReturnUrl to be taken back.
  \end{itemize}
  \\
  \textbf Function HTTP[Post] Login(args)
  \begin{itemize}
    \item Expected Arguments:
    LoginViewModel model;
    string returnUrl = null;
    \item Returns:
    The user to the previous page if complete.
    \\
    Locks the user out if the number of attempts are exceeded.
    \\
    Refreshes the page if something unexpected occurs.
    \item Description:
    Uses the async feature in order to access the account model.Email, model.Password, model.RememberMe and test the login. After which the reponse is returned in any as one of the above situations.
  \end{itemize}

  \textbf Function: HTTP[Get] Register(args)
  \begin{itemize}
    \item Expected Arguments:
    string returnUrl = null;
    \item Returns:
    The View of Register.cshtml.
    \item Description:
    Displays the Register page and stores the ReturnUrl.
  \end{itemize}

  \textbf Function: HTTP[Post] Register(args)
  \begin{itemize}
    \item Expected Arguments:
    RegisterViewModel model;
    string returnUrl = null;
    \item Returns:
    Upon successful registration the user is returned to the previous page.

    If an error occurred within the registration process the user is shown the error or the page is refreshed as something unexpected occurred.
    \item Description:
    The function creates a new ApplicationUser and stores the email/username and password in model.Email/Username and model.Password respectivly. They are then signed in or shown the errors that may have occurred during the account creation.
  \end{itemize}

\subsection{ManageController}
At revision 0 there are no account management options available to users so the functions that came with 'ASP.net' won't be referenced below. If the management options are expanded to include these pages or options at the time of revision 1 they will be included.

\subsection{ImagePoseDrawController}
In order to run pose estimation from the web interface the MVC has to access a database and external software which is done through the ImagePoseDraw Controller. The two important variables declared in the Controller are ApplicationDbContext \_context, and IHostingEnvironment \_environment and will be referred to by their variable names throughout. In addition to two variables

  \textbf Function: DataTable()
  \begin{itemize}
    \item Expected Arguments:
    NA
    \item Returns:
    The View of DataTable.cshtml.
    \item Description:
    Is used to display the Datatable that contains the uploaded media.
  \end{itemize}

  \textbf Function: DoesImageExist(args)
  \begin{itemize}
    \item Expected Arguments:
    int id;
    \item Returns:
    A boolean.
    \item Description:
    Uses the async feature in order to determine if the image exists within the PoseDrawnImages Model.
  \end{itemize}

  \textbf Function: ImagePoseDrawController(args)
  \begin{itemize}
    \item Expected Arguments:
    ApplicationdbContext context;
    IHostingEnvironment environment;
    \item Returns:
    NA
    \item Description:
    Using dependency injection the database context and environment are set in the controller.
  \end{itemize}

  \textbf Function: Index()
  \begin{itemize}
    \item Expected Arguments:
    NA
    \item Returns:
    Displays the View of Index.cshtml.
    \item Description:
    The index page displays a list of Names, Descriptions and Pose Estimated images.
  \end{itemize}

  \textbf Function: Details()
  \begin{itemize}
    \item Expected Arguments:
    int? id;
    \item Returns:
    If the id is null or the image found is null, it displays a Not Found page.
    \\
    If the id and image are not null it shows the Details.cshtml.
    \item Description:
    Returns a view of the pose estimated image, Name and Description or a Not Found page.
  \end{itemize}

  \textbf Function: HTTP[Get] Create()
  \begin{itemize}
    \item Expected Arguments:
    NA
    \item Returns:
    Displays the View of Create.cshtml.
    \item Description:
    Displays the page where new images are uploaded in order to set Name, Description and the image.
  \end{itemize}

  \textbf Function: HTTP[Post] Create(args)
  \begin{itemize}
    \item Expected Arguments:
    [Bind("ID, Name, Description")] PoseDrawnImage posedImage;
    IFormFile image;
    \item Returns:
    An asynchronous task that will return a view showing the ImagePoseDraw page or throwing an error.
    \item Description:
    The function inserts a new entry into the pose estimation database creating a unique ID. It takes in an image and saves the metadata before running pose estimation and storing the image after pose estimation. In order to accomplish this the function calls a estimate\_pose\_wrapper which takes in the raw image before running pose estimation, it then uploads the new image to the database in order to be called from the web.
  \end{itemize}

  \textbf Function: HTTP[Get] Edit()
  \begin{itemize}
    \item Expected Arguments:
    NA
    \item Returns:
    Displays the View of Edit.cshtml.
    \item Description:
    Displays the page where the Name and Description of an upload can be manipulated.
  \end{itemize}

  \textbf Function: HTTP[Post] Edit(args)
  \begin{itemize}
    \item Expected Arguments:
    int id;
    [Bind("ID, Name, Description")] PoseDrawnImage image;
    \item Returns:
    Returns a modified upload of the Name and Description to the ImagePoseDraw page.
    \item Description:
    Takes the id argument and uses \_context.Update in order to update changes that were made to the Name and Description.
  \end{itemize}

  \textbf Function: HTTP[Get] Delete(args)
  \begin{itemize}
    \item Expected Arguments:
    int? id;
    \item Returns:
    The ImagePoseDraw page with the upload removed if confirmation was successful, otherwise returns to the ImagePoseDraw page with the uploads still there.
    \item Description:
    Calls await Details(id) in order to confirm the removing of the upload.
  \end{itemize}

  \textbf Function: HTTP[Post] DeleteConfirmation(args)
  \begin{itemize}
    \item Expected Arguments:
    int id;
    \item Returns:
    The ImagePoseDraw page with the upload removed if confirmation was successful, otherwise returns to the ImagePoseDraw page with the uploads still there.
    \item Description:
    Uses the database \_context and PoseDrawnImages in order to remove the image when confirmed. Then redirects to the ImagePoseDraw page.
  \end{itemize}

\subsection{TextToMotionController}
The TextToMotion Controller will be used to preform full text search through the database once completed for the final revision. At this time it displays two pages and does not search the database.

  \textbf Function: Index()
  \begin{itemize}
    \item Expected Arguments:
    NA
    \item Returns:
    Displays the View of TextToMotion/Index.cshtml.
    \item Description:
    Calls the View of TextToMotion/Index.cshtml in order to show the page.
  \end{itemize}

  \textbf Function: Search(args)
  \begin{itemize}
    \item Expected Arguments:
    string Query;
    \item Returns:
    Displays the View of TextToMotion/Search.cshtml to show the page.
    \item Description:
    Calls the View of TextToMotion/Search.cshtml and saves the Title and Query in ViewData.
  \end{itemize}

\break


\section{Flowing Convnets - Human Pose Estimation}

\subsection{Overview}

This component of the project actually renders the skeleton overlay onto an image submitted to the website.
\\
Mapping out the joints of a person in an image requires the use of image manipulation and deep learning libraries. As of now, this proces is based on a research paper and is implemented with \textbf{Caffe} and \textbf{OpenCV} in \textbf{C++}. (*The parameters for functions given below will reference 'caffe' and 'cv' types in c++)



\subsection{Shared Object File}

The website is able to take an uploaded image and process it by using a shared object file (.so). The web app can make function calls to functions in the shared object file and pass in images as the parameters.
\\\\
The C++ file \textbf{"estimate\_pose.cpp"} contains all of the functions that interface with Caffe and OpenCV. The C file \textbf{"estimate\_pose\_wrapper.c"} is used to wrap the C++ function in C, and create the shared object file so that the C++ function can be accessed from the website.

\subsection{Pose Estimation C Program (estimate\_pose\_wrapper.c)}
The file \textbf{"estimate\_pose\_wrapper.c"} just contains 1 function. This function references a C++ function in \textbf{estimate\_pose.cpp}
\\\\
\textbf{function: int32\_t estimate\_pose\_wrapper(args)}
\begin{itemize}
    \item \textbf{Expected Arguments:}

    void\quad\textit{*image}
    \\
    uint32\_t\quad\textit{*size\_bytes}
    \\
    uint32\_t\quad\textit{max\_size\_Bytes}

    \item\quad\textbf{Returns:}

    if \textit{image} is processed and saved, returns:\\\textbf{int32\_t size}
    (describing size of file that was uploaded)
    \\\\
    else returns error object

    \item \textbf{Description:}

    this function makes a direct call to the C++ function \textbf{"estimate\_pose\_from\_c"} in \textbf{"estimate\_pose.cpp"} and simply returns the result of that C++ function call.
    \\
    The C++ function takes in the same args as this function
\end{itemize}

\subsection{Pose Estimation C++ Program (estimate\_pose.cpp)}

This C++ Program file contains 8 functions. All of these functions take in objects from the 'openCV'(cv) and 'Caffe'(caffe) libraries as arguments
\\\\
The key function in this file is \textbf{estimate\_pose\_from\_c}, and most of the functions serve as helpers to this function
\\\\
\textbf{List of Functions and Descriptions (PE = Pose Estimation):}
\\
\subsubsection{PE function 1: void channels\_from\_blob(args)}
\begin{itemize}
    \item \textbf{Expected Arguments:}

    std::vector\textless cv::Mat\textgreater\quad\textit{channels}
    \\
    boost::shared\_ptr\textless caffe::Blob\textgreater\quad\textit{blob}
    \\
    int32\_t\quad\textit{width}
    \\
    int32\_t\quad\textit{height}

    \item \textbf{Returns:}

    void (saves data into \textit{channels})

    \item \textbf{Description:}

    The \textit{blob} object contains concatenated mulit-channel data
    \\
    The \textit{channels} object is empty to begin with
    \\
    This function converts the raw data in a Caffe blob into a 'container of channels' (vector of openCV matrices)
    \\
    The \textit{width} and \textit{heigth} parameters let the program know what the dimensions of the channels are in the \textit{blob}
    \\
    The extracted information from \textit{blobs} is saved into the \textit{channels} vector
    \\\\
    This function is just used as a helper for other functions
\end{itemize}


\subsubsection{PE function 2: void copy\_image\_to\_input\_blob(args)}
\begin{itemize}
    \item \textbf{Expected Arguments:}

    caffe::Net \textless float\textgreater\quad\textit{heatmap\_net}
    \\
    cv::Mat\quad\textit{image}

    \item \textbf{Returns:}

    void (saves data into \textit{heatmap\_net})

    \item \textbf{Description:}

    This function converts the \textit{image} object from OpenCV BGR format to 32-bit-floating point RGB format and copies the image to the input blob of \textit{heatmap\_net}. It lso divides the input layer of the \textit{heatmap\_net} from a multi-channel array into several single-channel arrays by calling a helper function
    \\
    \textit{image} is the image that will serve as the input layer to the caffe network
    \\
    \textit{heatmap\_net} is the caffe network that will get its input layer filled with the RGB pixel data from \textit{image}
    \\\\
    This function makes a call to \textbf{PE-cpp function 1} when it splits up the newly updated image in \textit{heatmap\_net}'s input layer into several 'input\_channels'
\end{itemize}


\subsubsection{PE function 3: void get\_joints\_from\_network(args)}
\begin{itemize}
    \item \textbf{Expected Arguments:}

    cv::Point \quad\textit{*joints}
    \\
    cv::Size \quad\textit{channel\_size}
    \\
    caffe::Net\textless float\textgreater\quad\textit{heatmap\_net}

    \item \textbf{Returns:}

    void (saves data into \textit{joints})

    \item \textbf{Description:}

    This function uses the \textit{heatmap\_net}'s "conv5\_fusion" layer to get a set of joint locations for that heatmap.
    \\
    The joint locations get saved into \textit{*joints}
    \\
    The \textit{channel\_size} is used to maintain the accuracy of the position of the joints relative to the image as the image matrix is resized multiple times
    \\\\
    This function makes a call to \textbf{PE-cpp function 1} when it uses the \textit{heatmap\_net} to save all of the joint locations in a 'joint\_channel' vector of cv::Mat objects
\end{itemize}


\subsubsection{PE function 4: void draw\_skeleton(args)}
\begin{itemize}
    \item \textbf{Expected Arguments:}

    cv::Mat \quad\textit{image}
    \\
    cv::Point \quad\textit{*joints}

    \item \textbf{Returns:}

    void (saves image data into \textit{image})

    \item \textbf{Description:}

    This function uses the joint\_locations described in \textit{*joints} to draw an upper-body skeleton on the \textit{image} matrix passed in.
    \\
    \textit{image} is the image to draw the skeleton overlay on
    \\
    \textit{*joints} contain the locations for the set of joints (wrists, elbows, shoulders and head)
\end{itemize}

\subsubsection{PE function 5: std::unique\_ptr\textless caffe::Net\textless float\textgreater\textgreater init\_pose\_estimator\_network(args)}
\begin{itemize}
    \item \textbf{Expected Arguments:}

    std::string\quad\textit{model}
    \\
    std::string\quad\textit{trained\_weights}

    \item \textbf{Returns:}

    \textbf{std::unique\_ptr\textless caffe::Net\textless float\textgreater\textgreater} heatmap\_net
    \\
    pointer to an object that represents a whole caffe network

    \item \textbf{Description:}

    This function creates a Caffe network and copies over the trained layers from a given option for \textit{trained\_weights}
    \\
    For this application, a caffe network is initialized with the default settings:
    \\
    (\textit{model} = 'MODEL\_DEFAULT', \textit{trained\_weights} = TRAINED\_WEIGHTS\_DEFAULT)
\end{itemize}


\subsubsection{PE function 6: void image\_pose\_overlay(args)}
\begin{itemize}
    \item \textbf{Expected Arguments:}

    caffe::Net\textless float\textgreater\quad\textit{heatmap\_net}
    \\
    cv::Mat\quad\textit{image}

    \item \textbf{Returns:}

    void (saves to \textit{image})

    \item \textbf{Description:}

    This function processes the \textit{image} passed in using the \textit{heatmap\_net} to draw a skeleton on the openCV Matrix
    \\\\
    Details on the actions taken by the function:
    \begin{enumerate}
        \item Resizes \textit{image} to 256x256

        \item calls \textbf{PE function 2} to copy the image into the input layer of the \textit{heatmap\_net}

        \item after allowing the network to extract some data, declares an array object of cv::Point called \textit{joints}

        \item calls \textbf{PE function 3} to load in joint locations into \textit{joints}

        \item converts image to a format so that it can be drawn on by the program

        \item calls \textbf{PE function 4} to draw the skeleton overlay on top of the \textit{image}
    \end{enumerate}
\end{itemize}


\subsubsection{PE function 7: void square\_image\_with\_borders(args)}
\begin{itemize}
    \item \textbf{Expected Arguments:}

    cv::Mat\quad\textit{image\_mat}

    \item \textbf{Returns:}

    void (saves image data to \textit{image\_mat})

    \item \textbf{Description:}

    If the image's dimensions do not fit a square (length != width), this function makes it so that the image dimensions are expanded so that it fits into a square
    \\
    This is to avoid distorting the image drastically when the image is resized to 256x256
    \\\\
    This is just a simple helper function to pre-process the image
\end{itemize}



\subsubsection{PE function 8: int32\_t estimate\_pose\_from\_c(args)}
\begin{itemize}
    \item \textbf{Expected Arguments:}

    void\quad\textit{*image}
    \\
    uint32\_t\quad\textit{*size\_bytes}
    \\
    unit32\_t\quad\textit{max\_size\_bytes}

    \item \textbf{Returns:}

    if \textit{image} is processed and saved, returns:\\\textbf{int32\_t size}
    (describing size of file that was uploaded)
    \\\\
    else returns error object

    \item \textbf{Description:}

    This function is the key method in this file. This function overwrites the contents of the memory allocated for \textit{*image} so that a given image is updated to show the skeleton overlay on that image
    \\\\
    This function creates a new Caffe network and calls a lot of helper functions needed to process the \textit{image}
    \\\\
    Details on the actions taken by the function:
    \begin{enumerate}
        \item calls \textbf{PE function 5} to create a new caffe Network, stores new network in \textit{heatmap\_net}

        \item uses \textit{*image} and \textit{*size\_bytes} to create a cv::InputArray object to represent the uploaded image

        \item creates a cv::Mat image matrix, and decodes the contents of the cv::InputArray object into the newly created matrix object

        \item calls \textbf{PE function 7} to pre-process the image matrix to reaffirm that the image is square

        \item calls \textbf{PE function 6} using \textit{heatmap\_net} and the image matrix so that the image\_matrix includes the skeleton overlay

        \item converts and compresses the image\_matrix into a png

        \item finally, overwrites the contents of \textit{*image} with the newly created image that has the pose estimation 'skeleton overlay'
    \end{enumerate}

\end{itemize}




\section{Features In Development}

\subsection{Video Estimation C++ Program}

...
\subsection{Tensorflow}

..just mention to the possibility of using it...

\subsection{Standalone HTTP Server}

...

\chapter{Communication Protocol}

...just mention to HTTP...


\chapter{Development Details}

\section{Languages}
\section{Software}
\section{Hardware}


\end{document}
