\documentclass{scrreprt}

\usepackage{xcolor} % for different colour comments
\usepackage{tabto}
\usepackage{mdframed}
\mdfsetup{nobreak=true}
\usepackage{xkeyval}
\usepackage{tabularx}
\usepackage{booktabs}
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=red,
    urlcolor=blue
}
\usepackage[skip=2pt, labelfont=bf]{caption}
\usepackage{titlesec}
\usepackage{graphicx}
\usepackage[section]{placeins}
\graphicspath{ {image/} }

\titleformat{\paragraph}
{\normalfont\normalsize\bfseries}{\theparagraph}{1em}{}
\titlespacing*{\paragraph}
{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}


%% Comments
\newif\ifcomments\commentstrue

\ifcomments
\newcommand{\authornote}[3]{\textcolor{#1}{[#3 ---#2]}}
\newcommand{\todo}[1]{\textcolor{red}{[TODO: #1]}}
\else
\newcommand{\authornote}[3]{}
\newcommand{\todo}[1]{}
\fi

\newcommand{\wss}[1]{\authornote{magenta}{SS}{#1}}
\newcommand{\ds}[1]{\authornote{blue}{DS}{#1}}


%% The following are used for pretty printing of events and requirements
\makeatletter

\define@cmdkey      [TP] {test}     {name}       {}
\define@cmdkey      [TP] {test}     {desc}       {}
\define@cmdkey      [TP] {test}     {type}       {}
\define@cmdkey      [TP] {test}     {init}       {}
\define@cmdkey      [TP] {test}     {input}      {}
\define@cmdkey      [TP] {test}     {output}     {}
\define@cmdkey      [TP] {test}     {pass}       {}
\define@cmdkey      [TP] {test}     {user}       {}
\define@cmdkey      [TP] {test}     {reqnum}     {}


\newcommand{\getCurrentSectionNumber}{%
  \ifnum\c@section=0 %
  \thechapter
  \else
  \ifnum\c@subsection=0 %
  \thesection
  \else
  \ifnum\c@subsubsection=0 %
  \thesubsection
  \else
  \thesubsubsection
  \fi
  \fi
  \fi
}

\newcounter{TestNum}

\@addtoreset{TestNum}{section}
\@addtoreset{TestNum}{subsection}
\@addtoreset{TestNum}{subsubsection}

\newcommand{\testauto}[1]{
\setkeys[TP]{test}{#1}
\refstepcounter{TestNum}
\begin{mdframed}[linewidth=1pt]
\begin{tabularx}{\textwidth}{@{}p{3cm}X@{}}
{\bf Test \getCurrentSectionNumber.\theTestNum:} & {\bf \cmdTP@test@name}\\[\baselineskip]
{\bf Description:} & \cmdTP@test@desc\\[0.5\baselineskip]
{\bf Type:} & \cmdTP@test@type\\[0.5\baselineskip]
{\bf Initial State:} & \cmdTP@test@init\\[0.5\baselineskip]
{\bf Input:} & \cmdTP@test@input\\[0.5\baselineskip]
{\bf Output:} & \cmdTP@test@output\\[0.5\baselineskip]
{\bf Pass:} & \cmdTP@test@pass\\[0.5\baselineskip]
{\bf Req. \#:} & \cmdTP@test@reqnum
\end{tabularx}
\end{mdframed}
}

\newcommand{\testmanual}[1]{
\setkeys[TP]{test}{#1}
\refstepcounter{TestNum}
\begin{mdframed}[linewidth=1pt]
\begin{tabularx}{\textwidth}{@{}p{3cm}X@{}}
{\bf Test \getCurrentSectionNumber.\theTestNum:} & {\bf \cmdTP@test@name}\\[\baselineskip]
{\bf Description:} & \cmdTP@test@desc\\[0.5\baselineskip]
{\bf Type:} & \cmdTP@test@type\\[0.5\baselineskip]
{\bf Testers:} & \cmdTP@test@user\\[0.5\baselineskip]
{\bf Pass:} & \cmdTP@test@pass\\[0.5\baselineskip]
{\bf Req. \#:} & \cmdTP@test@reqnum
\end{tabularx}
\end{mdframed}
}

\makeatother

\newcommand{\ZtoT}{
\begin{tabularx}{3.85cm}{@{}p{0.35cm}p{0.35cm}p{0.35cm}p{0.35cm}p{0.35cm}p{0.35cm}p{0.35cm}p{0.35cm}p{0.35cm}p{0.35cm}p{0.35cm}@{}}
0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10
\end{tabularx}
}

\begin{document}
\title{\bf Text to Motion Database\\[\baselineskip]\Large Design Document}
\author{Brendan Duke\\Andrew Kohnen\\Udip Patel\\David Pitkanen\\Jordan Viveiros}
\date{\today}

\maketitle

\pagenumbering{roman}
\tableofcontents
% \listoftables
% \listoffigures


\begin{table}[bp]
\caption*{\bf Revision History}
\begin{tabularx}{\textwidth}{p{3.5cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
January 5, 2017 & 0.0 & File created\\
\bottomrule
\end{tabularx}
\end{table}

\newpage

\pagenumbering{arabic}

\chapter{User Experience}

\section{User Journey}

\section{Home Page}

\section{About}

\section{Contact}

\section{Sign Up}

\section{Login}

\section{Navigation Bar Links}

\section{Text to Motion}

\subsection{Search}

\subsection{Search Results}

\section{Image Pose Draw}

\subsection{Create}

\subsection{Edit/Details}

\subsection{View Uploads}





\chapter{Database Structure}

\section{Database Schema}
\section{Table Description}


\chapter{Module Decomposition}

\section{Text To Motion - ASP.NET Application}


\subsection{Overview}

...might be a good place to mention .net MVC. Mention of how sections will be about Models, Controllers (referencing views)...

\subsection{Dependency Injection}

...describe anything important that is in project.json...

\subsection{Models}

    \begin{itemize}
        \item \textbf User

        ...

        \item \textbf ...
    \end{itemize}


\subsection{HomeController}

    \begin{itemize}
        \item \textbf FunctionName:

        ...description of func...

        ...reference any models used...

        ...reference the view that is returned...
    \end{itemize}

\subsection{AccountController}

...

\subsection{ManageController}

...

\subsection{ImagePoseDrawController}

...

\subsection{TextToMotionController}

...

\break

\section{Flowing Convnets - Human Pose Estimation}

\subsection{Overview}

This component of the project actually renders the skeleton overlay onto an image submitted to the website.
\\
Mapping out the joints of a person in an image requires the use of image manipulation and deep learning libraries. As of now, this proces is based on a research paper and is implemented with \textbf{Caffe} and \textbf{OpenCV} in \textbf{C++}. (*The parameters for functions given below will reference 'caffe' and 'cv' types in c++)


\subsection{Shared Object File}

The website is able to take an uploaded image and process it by using a shared object file (.so). The web app can make function calls to functions in the shared object file and pass in images as the parameters.
\\\\
The C++ file \textbf{"estimate\_pose.cpp"} contains all of the functions that interface with Caffe and OpenCV. The C file \textbf{"estimate\_pose\_wrapper.c"} is used to wrap the C++ function in C, and create the shared object file so that the C++ function can be accessed from the website.

\subsection{Pose Estimation C Program (estimate\_pose\_wrapper.c)}
The file \textbf{"estimate\_pose\_wrapper.c"} just contains 1 function. This function references a C++ function in \textbf{estimate\_pose.cpp}
\\\\
\textbf{function: int32\_t estimate\_pose\_wrapper(args)}
\begin{itemize}
    \item \textbf{Expected Arguments:}

    void\quad\textit{*image}
    \\
    uint32\_t\quad\textit{*size\_bytes}
    \\
    uint32\_t\quad\textit{max\_size\_Bytes}

    \item\quad\textbf{Returns:}

    if \textit{image} is processed and saved, returns:\\\textbf{int32\_t size}
    (describing size of file that was uploaded)
    \\\\
    else returns error object

    \item \textbf{Description:}

    this function makes a direct call to the C++ function \textbf{"estimate\_pose\_from\_c"} in \textbf{"estimate\_pose.cpp"} and simply returns the result of that C++ function call.
    \\
    The C++ function takes in the same args as this function
\end{itemize}

\subsection{Pose Estimation C++ Program (estimate\_pose.cpp)}

This C++ Program file contains 8 functions. All of these functions take in objects from the 'openCV'(cv) and 'Caffe'(caffe) libraries as arguments
\\\\
The key function in this file is \textbf{estimate\_pose\_from\_c}, and most of the functions serve as helpers to this function
\\\\
\underline{List of Functions and Descriptions (PE = Pose Estimation):}
\\
\subsubsection{References for Objects used in C++ functions}

\begin{itemize}
    \item \textbf{References for OpenCV objects}

    \href{http://docs.opencv.org/3.1.0/d3/d63/classcv_1_1Mat.html#details}{Reference to cv::Mat}
    \\
    \href{http://docs.opencv.org/3.1.0/db/d4e/classcv_1_1Point__.html}{Reference to cv::Point}
    \\
    \href{http://docs.opencv.org/3.1.0/d4/d32/classcv_1_1__InputArray.html}{Reference to cv::InputArray}


    \item \textbf{References for Caffe Objects}

    \href{http://caffe.berkeleyvision.org/doxygen/classcaffe_1_1Blob.html}{Reference to caffe::Blob}
    \\
    \href{http://caffe.berkeleyvision.org/doxygen/classcaffe_1_1Net.html}{Reference to caffe::Net}




    \item \textbf{References for Other Objects}

    \href{http://www.boost.org/doc/libs/1_63_0/libs/smart_ptr/shared_ptr.htm}{Reference to boost::shared\_ptr}

\end{itemize}

\subsubsection{PE function 1: void channels\_from\_blob(args)}
\begin{itemize}
    \item \textbf{Expected Arguments:}

    std::vector\textless cv::Mat\textgreater\quad\textit{channels}
    \\
    boost::shared\_ptr\textless caffe::Blob\textgreater\quad\textit{blob}
    \\
    int32\_t\quad\textit{width}
    \\
    int32\_t\quad\textit{height}

    \item \textbf{Returns:}

    void (saves data into \textit{channels})

    \item \textbf{Description:}

    The \textit{blob} object contains concatenated mulit-channel data
    \\
    The \textit{channels} object is empty to begin with
    \\
    This function converts the raw data in a Caffe blob into a 'container of channels' (vector of openCV matrices)
    \\
    The \textit{width} and \textit{heigth} parameters let the program know what the dimensions of the channels are in the \textit{blob}
    \\
    The extracted information from \textit{blobs} is saved into the \textit{channels} vector
    \\\\
    This function is just used as a helper for other functions
\end{itemize}


\subsubsection{PE function 2: void copy\_image\_to\_input\_blob(args)}
\begin{itemize}
    \item \textbf{Expected Arguments:}

    caffe::Net \textless float\textgreater\quad\textit{heatmap\_net}
    \\
    cv::Mat\quad\textit{image}

    \item \textbf{Returns:}

    void (saves data into \textit{heatmap\_net})

    \item \textbf{Description:}

    This function converts the \textit{image} object from OpenCV BGR format to 32-bit-floating point RGB format and copies the image to the input blob of \textit{heatmap\_net}. It lso divides the input layer of the \textit{heatmap\_net} from a multi-channel array into several single-channel arrays by calling a helper function
    \\
    \textit{image} is the image that will serve as the input layer to the caffe network
    \\
    \textit{heatmap\_net} is the caffe network that will get its input layer filled with the RGB pixel data from \textit{image}
    \\\\
    This function makes a call to \textbf{PE-cpp function 1} when it splits up the newly updated image in \textit{heatmap\_net}'s input layer into several 'input\_channels'
\end{itemize}


\subsubsection{PE function 3: void get\_joints\_from\_network(args)}
\begin{itemize}
    \item \textbf{Expected Arguments:}

    cv::Point \quad\textit{*joints}
    \\
    cv::Size \quad\textit{channel\_size}
    \\
    caffe::Net\textless float\textgreater\quad\textit{heatmap\_net}

    \item \textbf{Returns:}

    void (saves data into \textit{joints})

    \item \textbf{Description:}

    This function uses the \textit{heatmap\_net}'s "conv5\_fusion" layer to get a set of joint locations for that heatmap. (This layer is derived from the research paper used)
    \\
    The joint locations get saved into \textit{*joints}
    \\
    The \textit{channel\_size} is used to maintain the accuracy of the position of the joints relative to the image as the image matrix is resized multiple times
    \\\\
    This function makes a call to \textbf{PE-cpp function 1} when it uses the \textit{heatmap\_net} to save all of the joint locations in a 'joint\_channel' vector of cv::Mat objects
\end{itemize}


\subsubsection{PE function 4: void draw\_skeleton(args)}
\begin{itemize}
    \item \textbf{Expected Arguments:}

    cv::Mat \quad\textit{image}
    \\
    cv::Point \quad\textit{*joints}

    \item \textbf{Returns:}

    void (saves image data into \textit{image})

    \item \textbf{Description:}

    This function uses the joint\_locations described in \textit{*joints} to draw an upper-body skeleton on the \textit{image} matrix passed in.
    \\
    \textit{image} is the image to draw the skeleton overlay on
    \\
    \textit{*joints} contain the locations for the set of joints (wrists, elbows, shoulders and head)
\end{itemize}

\subsubsection{PE function 5: std::unique\_ptr\textless caffe::Net\textless float\textgreater\textgreater init\_pose\_estimator\_network(args)}
\begin{itemize}
    \item \textbf{Expected Arguments:}

    std::string\quad\textit{model}
    \\
    std::string\quad\textit{trained\_weights}

    \item \textbf{Returns:}

    \textbf{std::unique\_ptr\textless caffe::Net\textless float\textgreater\textgreater} heatmap\_net
    \\
    pointer to an object that represents a whole caffe network

    \item \textbf{Description:}

    This function creates a Caffe network and copies over the trained layers from a given option for \textit{trained\_weights}
    \\
    For this application, a caffe network is initialized with the default settings:
    \\
    (\textit{model} = 'MODEL\_DEFAULT', \textit{trained\_weights} = TRAINED\_WEIGHTS\_DEFAULT)
\end{itemize}


\subsubsection{PE function 6: void image\_pose\_overlay(args)}
\begin{itemize}
    \item \textbf{Expected Arguments:}

    caffe::Net\textless float\textgreater\quad\textit{heatmap\_net}
    \\
    cv::Mat\quad\textit{image}

    \item \textbf{Returns:}

    void (saves to \textit{image})

    \item \textbf{Description:}

    This function processes the \textit{image} passed in using the \textit{heatmap\_net} to draw a skeleton on the openCV Matrix
    \\\\
    Details on the actions taken by the function:
    \begin{enumerate}
        \item Resizes \textit{image} to 256x256

        \item calls \textbf{PE function 2} to copy the image into the input layer of the \textit{heatmap\_net}

        \item after allowing the network to extract some data, declares an array object of cv::Point called \textit{joints}

        \item calls \textbf{PE function 3} to load in joint locations into \textit{joints}

        \item converts image to a format so that it can be drawn on by the program

        \item calls \textbf{PE function 4} to draw the skeleton overlay on top of the \textit{image}
    \end{enumerate}
\end{itemize}


\subsubsection{PE function 7: void square\_image\_with\_borders(args)}
\begin{itemize}
    \item \textbf{Expected Arguments:}

    cv::Mat\quad\textit{image\_mat}

    \item \textbf{Returns:}

    void (saves image data to \textit{image\_mat})

    \item \textbf{Description:}

    If the image's dimensions do not fit a square (length != width), this function makes it so that the image dimensions are expanded so that it fits into a square
    \\
    This is to avoid distorting the image drastically when the image is resized to 256x256
    \\\\
    This is just a simple helper function to pre-process the image
\end{itemize}



\subsubsection{PE function 8: int32\_t estimate\_pose\_from\_c(args)}
\begin{itemize}
    \item \textbf{Expected Arguments:}

    void\quad\textit{*image}
    \\
    uint32\_t\quad\textit{*size\_bytes}
    \\
    unit32\_t\quad\textit{max\_size\_bytes}

    \item \textbf{Returns:}

    if \textit{image} is processed and saved, returns:\\\textbf{int32\_t size}
    (describing size of file that was uploaded)
    \\\\
    else returns error object

    \item \textbf{Description:}

    This function is the key method in this file. This function overwrites the contents of the memory allocated for \textit{*image} so that a given image is updated to show the skeleton overlay on that image
    \\\\
    This function creates a new Caffe network and calls a lot of helper functions needed to process the \textit{image}
    \\\\
    Details on the actions taken by the function:
    \begin{enumerate}
        \item calls \textbf{PE function 5} to create a new caffe Network, stores new network in \textit{heatmap\_net}

        \item uses \textit{*image} and \textit{*size\_bytes} to create a cv::InputArray object to represent the uploaded image

        \item creates a cv::Mat image matrix, and decodes the contents of the cv::InputArray object into the newly created matrix object

        \item calls \textbf{PE function 7} to pre-process the image matrix to reaffirm that the image is square

        \item calls \textbf{PE function 6} using \textit{heatmap\_net} and the image matrix so that the image\_matrix includes the skeleton overlay

        \item converts and compresses the image\_matrix into a png

        \item finally, overwrites the contents of \textit{*image} with the newly created image that has the pose estimation 'skeleton overlay'
    \end{enumerate}

\end{itemize}


\break

\section{Features In Development}

\subsection{Pose Estimation For Videos (C++)}

Since a video can be considered as just a set (or array) of images, this pose estimation algorithm can be executed on videos as well as images. At this point in the project,a C++ program does exist that references a function from the file \textbf{"estimate\_pose.cpp"} to analyze videos, but the code has not been finalized. It is also far too slow to be used from a web interface.
\\\\
Since this functionality is not a part of the system yet, this module was not given a formal declaration/definition. In addition to the reasons mentioned above, the Caffe submodule as a whole will soon be replaced by a newer deep learning framework described in the section below (Tensorflow). So this module is not going to be included in the final revision of this document

\subsection{Tensorflow}

Moving Forward, the Caffe deep learning framework (C++) will be replaced by Tensorflow. Tensorflow is a newer framework with more support for developers compared to Caffe. Tensorflow is a library in Python that can generate graphs needed for neural networks and deep learning algorithms. Replacing the deep learning framework will not drastically change the logic of the web application. The web application would just refer to a different kind of executable when processing an uploaded image (it refers to a shared object file as of now).
\\\\
The project repository contains several test Python files and functions that work with the simpler aspects of Tensorflow. These are attempts at trying to learn Tensorflow and the functions or files are not referenced by the ASP.NET web app at all. Since these files are separate from the functionality of the main application, these modules detailing Tensorflow test code have not been included in the design documentation.

\subsection{Standalone HTTP Server}



\chapter{Communication Protocol}

...just mention to HTTP...


\chapter{Development Details}

\section{Languages}
\section{Software}
\section{Hardware}


\end{document}
