<script>
    var video = $('video')[0];
    var EXPECTED_DIM = 384;

    function elemByID(id) { return document.getElementById(id); }

    var ProcessStreamVM = function () {
        var self = this;

        self.sendFrames = ko.observable(true);
        self.mode = ko.observable('joints');
        self.serverURL = ko.computed(function () {
            if (self.mode() == 'joints') return 'https://brendanduke.ca:8765/';
            else if (self.mode() == 'heatmap') return 'https://brendanduke.ca:8765/heatmap';
            else if (self.mode() == 'activation_map') return 'https://brendanduke.ca:8765/activation_map'
            else return '';
        });
        self.batchSize = ko.observable(16);

        self.framesQueue = ko.observableArray([]);
        self.framesToCombine = ko.observableArray([]);
        self.framesSent = ko.observableArray([]);

        self.jointsToRender = ko.observableArray([]);
        self.heatmapsToRender = ko.observableArray([]);

        self.mode.subscribe(function () {
            self.framesQueue([]);
            self.framesToCombine([]);
            self.framesSent([]);

            self.jointsToRender([]);
            self.heatmapsToRender([]);
        });

        self.fillCanvasParams = function (canvas, width, height) {
            canvas.fillStyle = 'red';
            canvas.width = width;
            canvas.height = height;
            var canvasCtx = canvas.getContext('2d');

            return { 'canvas': canvas, 'canvasCtx': canvasCtx };
        }

        self.initCanvasByID = function (ID, width, height) {
            var canvas = elemByID(ID);
            self.fillCanvasParams(canvas, width, height);
        }

        self.createCanvas = function (width, height) {
            var canvas = document.createElement('canvas');
            return self.fillCanvasParams(canvas, width, height);
        }

        self.addFrameToQueue = function (queue, base64Image) {
            if (queue.length == self.batchSize()) {
                queue.shift();
                queue.push(base64Image);
            }
            else {
                queue.push(base64Image);
            }
        }

        self.sendFramesToBeProcessed = function () {
            self.framesQueue().forEach(function (imageData) {
                self.framesSent.push(imageData);
            });
            self.framesQueue([]);

            //combine all frames to combine into bigCanvas
            var bigCanvas = vm.createCanvas(EXPECTED_DIM, vm.batchSize() * EXPECTED_DIM);
            for (var i = 0; i < vm.batchSize(); ++i) {
                var frame = self.framesToCombine()[i];
                bigCanvas.canvasCtx.putImageData(frame, 0, i * EXPECTED_DIM);
            }
            bigCanvas.canvasCtx.drawImage(bigCanvas.canvas, 0, 0);

            var bigImageJpeg = bigCanvas.canvas.toDataURL('image/jpeg').split(',')[1];

            bigCanvas.canvas.remove();

            //send image data url to server
            $.post(self.serverURL(),
                JSON.stringify(bigImageJpeg),
                function (response) {
                    if (self.mode() == 'joints') {
                        response.forEach(function(jointsForImage) {
                            self.jointsToRender.push(jointsForImage);
                        });
                    }
                    else if (self.mode() == 'heatmap') {
                        self.addFramesToDisplay(response, 'heatmap');                        
                    }
                    else if (self.mode() == 'activation_map') {
                        //todo
                    }

                },
                "json")
                .fail(function (response) {
                    self.sendFrames(false);
                    setTimeout(function () {
                        self.sendFrames(true);
                    }, 3000);
                });
        }

        self.addFramesToDisplay = function (imageBatch, mode) {
            var batchCanvas = vm.createCanvas(EXPECTED_DIM, vm.batchSize() * EXPECTED_DIM);
            var largeImage = new Image();
            largeImage.onload = function () {
                batchCanvas.canvasCtx.drawImage(this, 0, 0, EXPECTED_DIM, vm.batchSize() * EXPECTED_DIM);

                for (var i = 0; i < vm.batchSize(); i++) {
                    var segmentedImage = batchCanvas.canvasCtx.getImageData(
                        0, i * EXPECTED_DIM, EXPECTED_DIM, EXPECTED_DIM);
                    vm.heatmapsToRender.push(segmentedImage);
                }
            }

            largeImage.src = 'data:image/jpeg;base64,' + imageBatch;
        }

    }

    //custom bindings and helper funcs (ignore)
    ko.bindingHandlers.fadeVisible = {
        init: function (element, valueAccessor) {
            var value = valueAccessor();
            $(element).toggle(ko.utils.unwrapObservable(value));
        },
        update: function (element, valueAccessor) {
            var value = valueAccessor();
            ko.utils.unwrapObservable(value) ? $(element).fadeIn() : $(element).hide();
        }
    };
    //init ko viewmodel
    window.vm = new ProcessStreamVM();
    ko.applyBindings(vm);

    vm.initCanvasByID('heatmap-canvas', EXPECTED_DIM, EXPECTED_DIM);
    vm.initCanvasByID('joint-location-canvas', EXPECTED_DIM, EXPECTED_DIM);

    function renderHeatmapOverlay() {
        var canvasToDisplay = elemByID('heatmap-canvas');
        var canvasToDisplayCtx = canvasToDisplay.getContext('2d');

        var origImgData = vm.framesSent()[0];

        var heatmap = vm.heatmapsToRender()[0];

        var heatmapData = heatmap.data;
        //remove all pixels that are entirely black
        var data = origImgData.data;
        for (var n = 0; n < (4*EXPECTED_DIM*EXPECTED_DIM); n += 4) {
            data[n + 0] = 0.5*data[n + 0] + 0.5*heatmapData[n + 0];
            data[n + 1] = 0.5*data[n + 1] + 0.5*heatmapData[n + 1];
            data[n + 2] = 0.5*data[n + 2] + 0.5*heatmapData[n + 2];
        }

        canvasToDisplayCtx.putImageData(origImgData, 0, 0);
        canvasToDisplayCtx.drawImage(canvasToDisplay, 0, 0);

        vm.framesSent.shift();
        vm.heatmapsToRender.shift();
    }

    // take the screenshot and draw it onto the canvas (positioned to crop the sides)
    // convert canvas to base64 image, add the frame to the 'framesToSend' array
    function eventLoop() {
        if (video.clientHeight == 320)
            return;

        var videoWidth = video.clientWidth;
        var videoHeight = video.clientHeight;
        var offsetX = (videoWidth - videoHeight) / 2;

        var canvas = vm.createCanvas(EXPECTED_DIM, EXPECTED_DIM);

        canvas.canvasCtx.drawImage(
            video,
            offsetX, 0, videoWidth - 2 * offsetX, videoHeight,
            0, 0, EXPECTED_DIM, EXPECTED_DIM
        );

        var imageData = canvas.canvasCtx.getImageData(
            0, 0, EXPECTED_DIM, EXPECTED_DIM);
        vm.addFrameToQueue(vm.framesQueue(), imageData);
        vm.addFrameToQueue(
            vm.framesToCombine(),
            canvas.canvasCtx.getImageData(0, 0, canvas.canvas.width, canvas.canvas.height));

        if (vm.sendFrames() && (vm.framesQueue().length >= vm.batchSize())) {
            vm.sendFramesToBeProcessed();
        }

        canvas.canvas.remove();

        if ((vm.mode() == 'heatmap') && (vm.heatmapsToRender().length > 0)) {
            renderHeatmapOverlay();
        } else if ((vm.mode() == 'joints') && (vm.jointsToRender().length > 0)) {
            var canvasToDisplay = elemByID('joint-location-canvas');
            var canvasToDisplayCtx = canvasToDisplay.getContext('2d');

            canvasToDisplayCtx.putImageData(vm.framesSent()[0], 0, 0);
            canvasToDisplayCtx.drawImage(canvasToDisplay, 0, 0);

            var jointsToRenderForFrame = vm.jointsToRender()[0];
            $.each(jointsToRenderForFrame,
                   function(propertyName, value) {
                       console.log(value[0] + ' ' + value[1]);

                       var maxDim = Math.max(EXPECTED_DIM, EXPECTED_DIM);
                       var x = maxDim*value[0] + EXPECTED_DIM/2;
                       var y = maxDim*value[1] + EXPECTED_DIM/2;

                       canvasToDisplayCtx.beginPath();
                       var circle = canvasToDisplayCtx.arc(x, y, 10, 0, 2*Math.PI);
                       canvasToDisplayCtx.fill(circle);
            });

            vm.framesSent.shift();
            vm.jointsToRender.shift();
        }
    }

    //webcam capture + eventloop init
    function handleSuccessFact(video) {
        return function (stream) {
            window.stream = stream;
            video.srcObject = stream;
        }
    }

    function handleError(error, video) {
        console.log('navigator.getUserMedia error: ', error);
    }

    $(document).ready(function () {
        var video = $('video')[0];
        var constraints = {
            audio: false,
            video: true
        };

        navigator.mediaDevices.getUserMedia(constraints)
            .then(handleSuccessFact(video))
            .catch(handleError);

        setInterval(eventLoop, 200);
    });
</script>
