<script>
    var video = $('video')[0];
    var EXPECTED_DIM = 384;

    function elemByID(id) { return document.getElementById(id); }

    var ProcessStreamVM = function () {
        var self = this;

        self.sendFrames = ko.observable(true);
        self.mode = ko.observable('joints');
        self.serverURL = ko.computed(function () {
            if (self.mode() == 'joints') return 'https://brendanduke.ca:8765/';
            else if (self.mode() == 'heatmap') return 'https://brendanduke.ca:8765/heatmap';
            else if (self.mode() == 'activation_map') return 'https://brendanduke.ca:8765/activation_map'
            else return '';
        });
        self.batchSize = ko.observable(16);
        
        self.framesQueue = ko.observableArray([]);
        self.framesToCombine = ko.observableArray([]);
        self.framesSent = ko.observableArray([]);

        self.jointsToRender = ko.observableArray([]);
        self.framesToDisplay = ko.observableArray([]);


        self.initCanvasByID = function (ID, width, height) {
            var canvas = elemByID(ID);
            canvas.fillStyle = 'red';
            canvas.width = width;
            canvas.height = height;
            var canvasCtx = canvas.getContext('2d');

            return { 'canvas': canvas, 'canvasCtx': canvasCtx };
        }

        self.createCanvas = function (width, height) {
            var canvas = document.createElement('canvas');
            canvas.fillStyle = 'red';
            canvas.width = width;
            canvas.height = height;
            var canvasCtx = canvas.getContext('2d');

            return { 'canvas': canvas, 'canvasCtx': canvasCtx };
        }


        self.addFrameToQueue = function (queue, base64Image) {
            if (queue.length == self.batchSize()) {
                queue.splice(0, queue.length);
                queue.push(base64Image);
            }
            else {
                queue.push(base64Image);
            }
        }

        self.sendFramesToBeProcessed = function () {
            self.framesSent([]);
            self.framesQueue().forEach(function (frame) {
                self.framesSent.push('data:image/jpeg;base64,' + frame);
            });

            //combine all frames to combine into bigCanvas
            var bigCanvas = vm.createCanvas(EXPECTED_DIM, vm.batchSize() * EXPECTED_DIM);
            for (var i = 0; i < vm.batchSize(); ++i) {
                var frame = self.framesToCombine()[i];
                bigCanvas.canvasCtx.putImageData(frame, 0, i * EXPECTED_DIM);
            }
            bigCanvas.canvasCtx.drawImage(bigCanvas.canvas, 0, 0);

            var bigImageJpeg = bigCanvas.canvas.toDataURL('image/jpeg').split(',')[1];

            bigCanvas.canvas.remove();


            //send image data url to server
            $.post(self.serverURL(),
                JSON.stringify(bigImageJpeg),
                function (response) {

                    if (self.mode() == 'joints') {
                        
                    }
                    else if (self.mode() == 'heatmap') {
                        self.addFramesToDisplay(response, 'heatmap');                        
                    }
                    else if (self.mode() == 'activation_map') {
                        //todo
                    }

                },
                "json")
                .fail(function (response) {
                    self.sendFrames(false);
                    setTimeout(function () {
                        self.sendFrames(true);
                    }, 3000);
                });
        }




        self.addFramesToDisplay = function (imageBatch, mode) {
            var batchCanvas = vm.createCanvas(EXPECTED_DIM, vm.batchSize() * EXPECTED_DIM);
            var largeImage = new Image();
            largeImage.onload = function () {
                batchCanvas.canvasCtx.drawImage(this, 0, 0, EXPECTED_DIM, vm.batchSize() * EXPECTED_DIM);

                for (var i = 0; i < vm.batchSize(); i++) {
                    var segmentedImage = batchCanvas.canvasCtx.getImageData(0, i * EXPECTED_DIM, EXPECTED_DIM, EXPECTED_DIM);
                    vm.framesToDisplay.push(segmentedImage);
                }
            }

            largeImage.src = 'data:image/jpeg;base64,' + imageBatch;
        }

    }
    //custom bindings and helper funcs (ignore)
    ko.bindingHandlers.fadeVisible = {
        init: function (element, valueAccessor) {
            var value = valueAccessor();
            $(element).toggle(ko.utils.unwrapObservable(value));
        },
        update: function (element, valueAccessor) {
            var value = valueAccessor();
            ko.utils.unwrapObservable(value) ? $(element).fadeIn() : $(element).hide();
        }
    };
    //init ko viewmodel
    window.vm = new ProcessStreamVM();
    ko.applyBindings(vm);


    function renderHeatmapOverlay() {
        var canvasToDisplay = vm.initCanvasByID('heatmap-canvas');

        var originalImage = new Image();

        originalImage.onload = function () {
            canvasToDisplay.canvasCtx.drawImage(this, 0, 0);
        }
        

        /*
        heatmapImage.onload = function () {
            heatmapContext.drawImage(this, 0, 0, videoWidth, videoHeight,
                destinationOffsetX, destinationOffsetY, videoWidth, videoHeight
            );


            var heatmapImageData = heatmapContext.getImageData(0, 0, videoWidth, videoHeight);
            var originalImageData = originalImageContext.getImageData(0, 0, videoWidth, videoHeight);
            //will update this func so that the originalImageData is made transparent at the spots at which the heatmap blobs exist

            var data = heatmapImageData.data;
            //remove all pixels that are entirely black
            for (var y = 0; y < videoHeight; y++) {
                for (var x = 0; x < videoWidth; x++) {
                    var n = ((videoWidth * y) + x) * 4;
                    if (data[n] + data[n + 1] + data[n + 2] == 0) {
                        data[n + 3] = 0;
                    }
                    else {
                        data[n + 3] = 125;

                    }
                }
            }


            .putImageData(heatmapImageData, 0, 0);
            originalImageContext.drawImage(heatmapCanvas, 0, 0);
        }*/

        if (vm.framesToDisplay().length > 0 && vm.framesSent().length > 0) {
            console.log(vm.framesToDisplay());
            originalImage.src = vm.framesSent()[0];
            //vm.framesToDisplay.shift();
            vm.framesSent.shift();
        }
    }



    





    function eventLoop() {
        if (video.clientHeight == 320) return;

        var videoWidth = video.clientWidth;
        var videoHeight = video.clientHeight;
        var offsetX = (videoWidth - videoHeight) / 2;

        //temporary canvas used to take a screenshot of the video and crop the sides off
        var canvas = vm.createCanvas(EXPECTED_DIM, EXPECTED_DIM);

        //take the screenshot and draw it onto the canvas (positioned to crop the sides)
        canvas.canvasCtx.drawImage(
            video, offsetX, 0, videoWidth - 2 * offsetX, videoHeight,
            0, 0, EXPECTED_DIM, EXPECTED_DIM
        );

        //convert canvas to base64 image, add the frame to the 'framesToSend' array
        var imageJpeg = canvas.canvas.toDataURL('image/jpeg').split(',')[1];
        vm.addFrameToQueue(vm.framesQueue(), imageJpeg);
        vm.addFrameToQueue(vm.framesToCombine(),
            canvas.canvasCtx.getImageData(0, 0, canvas.canvas.width, canvas.canvas.height)
        );

        if (vm.sendFrames() && (vm.framesQueue().length == vm.batchSize())) {
            vm.sendFramesToBeProcessed();
        }

        canvas.canvas.remove();


        //render if frames to display or joints are available...
        if (vm.mode() == 'heatmap') renderHeatmapOverlay();
        
    }
















    //webcam capture + eventloop init
    function handleSuccessFact(video) {
        return function (stream) {
            window.stream = stream;
            video.srcObject = stream;
        }
    }

    function handleError(error, video) {
        console.log('navigator.getUserMedia error: ', error);
    }


    $(document).ready(function () {
        var video = $('video')[0];
        var constraints = {
            audio: false,
            video: true
        };

        navigator.mediaDevices.getUserMedia(constraints)
            .then(handleSuccessFact(video))
            .catch(handleError);

        setInterval(eventLoop, 500);
    });
</script>