<script>
    var video = $('video')[0];
    var EXPECTED_DIM = 384;

    function elemByID(id) { return document.getElementById(id); }

    var ProcessStreamVM = function () {
        var self = this;

        self.sendFrames = ko.observable(true);
        self.mode = ko.observable('joints');
        self.serverURL = ko.computed(function () {
            if (self.mode() == 'joints') return 'https://brendanduke.ca:8765/';
            else if (self.mode() == 'heatmap') return 'https://brendanduke.ca:8765/heatmap';
            else if (self.mode() == 'activation_map') return 'https://brendanduke.ca:8765/activation_map'
            else return '';
        });
        self.batchSize = ko.observable(16);

        self.imageToSend = ko.observable('');
        self.framesQueue = ko.observableArray([]);
        self.framesToCombine = ko.observableArray([]);
        self.framesSent = ko.observableArray([]);

        self.jointsToRender = ko.observableArray([]);
        self.framesToDisplay = ko.observableArray([]);


        self.initCanvasByID = function (ID, width, height) {
            var canvas = elemByID(ID);
            canvas.fillStyle = 'red';
            canvas.width = width;
            canvas.height = height;
            var canvasCtx = canvas.getContext('2d');

            return { 'canvas': canvas, 'canvasCtx': canvasCtx };
        }

        self.createCanvas = function (width, height) {
            var canvas = document.createElement('canvas');
            canvas.fillStyle = 'red';
            canvas.width = width;
            canvas.height = height;
            var canvasCtx = canvas.getContext('2d');

            return { 'canvas': canvas, 'canvasCtx': canvasCtx };
        }


        self.addFrameToQueue = function (base64Image) {
            if (self.framesQueue().length == self.batchSize()) {
                self.framesQueue([]);
                self.framesQueue.push(base64Image);
            }
            else {
                self.framesQueue.push(base64Image);
            }
        }


        self.addRGBFrameToCombine = function (imageData) {
            if (self.framesToCombine().length == self.batchSize()) {
                self.framesToCombine([]);
                self.framesToCombine.push(imageData);
            }
            else {
                self.framesToCombine.push(imageData);
            }
        }


        self.sendFramesToBeProcessed = function () {
            self.framesQueue().forEach(function (frame) {
                self.framesSent.push('data:image/jpeg;base64,' + frame);
            });

            //combine all frames to combine into bigCanvas
            var bigCanvas = vm.createCanvas(vm.batchSize() * EXPECTED_DIM, EXPECTED_DIM);
            for (var i = 0; i < vm.batchSize(); ++i) {
                var frame = self.framesToCombine()[i];
                bigCanvas.canvasCtx.putImageData(frame, i * EXPECTED_DIM, 0);
            }
            bigCanvas.canvasCtx.drawImage(bigCanvas.canvas, 0, 0);

            var bigImageJpeg = bigCanvas.canvas.toDataURL('image/jpeg').split(',')[1];

            bigCanvas.canvas.remove();


            //send image data url to server
            $.post(self.serverURL(),
                JSON.stringify(bigImageJpeg),
                function (response) {
                    console.log(response);

                    //...



                },
                "json")
                .fail(function (response) {
                    self.sendFrames(false);
                    setTimeout(function () {
                        self.sendFrames(true);
                    }, 3000);
                });

        }


    }
    //custom bindings and helper funcs (ignore)
    ko.bindingHandlers.fadeVisible = {
        init: function (element, valueAccessor) {
            var value = valueAccessor();
            $(element).toggle(ko.utils.unwrapObservable(value));
        },
        update: function (element, valueAccessor) {
            var value = valueAccessor();
            ko.utils.unwrapObservable(value) ? $(element).fadeIn() : $(element).hide();
        }
    };
    //init ko viewmodel
    window.vm = new ProcessStreamVM();
    ko.applyBindings(vm);








    function eventLoop() {
        if (video.clientHeight == 320) return;

        var videoWidth = video.clientWidth;
        var videoHeight = video.clientHeight;
        var offsetX = (videoWidth - videoHeight) / 2;

        //temporary canvas used to take a screenshot of the video and crop the sides off
        var canvas = vm.createCanvas(EXPECTED_DIM, EXPECTED_DIM);

        //take the screenshot and draw it onto the canvas (positioned to crop the sides)
        canvas.canvasCtx.drawImage(
            video, offsetX, 0, videoWidth - 2 * offsetX, videoHeight,
            0, 0, EXPECTED_DIM, EXPECTED_DIM
        );

        //convert canvas to base64 image, add the frame to the 'framesToSend' array
        var imageJpeg = canvas.canvas.toDataURL('image/jpeg').split(',')[1];
        vm.addFrameToQueue(imageJpeg);
        vm.addRGBFrameToCombine(
            canvas.canvasCtx.getImageData(0, 0, canvas.canvas.width, canvas.canvas.height)
        )

        if (vm.sendFrames() && (vm.framesQueue().length == vm.batchSize())) {
            vm.sendFramesToBeProcessed();
        }

        canvas.canvas.remove();


        //render if frames to display or joints are available...

    }
















    //webcam capture + eventloop init
    function handleSuccessFact(video) {
        return function (stream) {
            window.stream = stream;
            video.srcObject = stream;
        }
    }

    function handleError(error, video) {
        console.log('navigator.getUserMedia error: ', error);
    }


    $(document).ready(function () {
        var video = $('video')[0];
        var constraints = {
            audio: false,
            video: true
        };

        navigator.mediaDevices.getUserMedia(constraints)
            .then(handleSuccessFact(video))
            .catch(handleError);

        setInterval(eventLoop, 500);
    });
</script>