<script>
    var video = $('video')[0];
    var EXPECTED_DIM = 384;

    function elemByID(id) { return document.getElementById(id); }

    var ProcessStreamVM = function () {
        var self = this;

        self.sendFrames = ko.observable(true);
        self.mode = ko.observable('joints');
        self.serverURL = ko.computed(function () {
            if (self.mode() == 'joints') return 'https://brendanduke.ca:8765/';
            else if (self.mode() == 'heatmap') return 'https://brendanduke.ca:8765/heatmap';
            else if (self.mode() == 'activation_map') return 'https://brendanduke.ca:8765/activation_map'
            else return '';
        });
        self.batchSize = ko.observable(16);
        
        self.framesQueue = ko.observableArray([]);
        self.framesToCombine = ko.observableArray([]);
        self.framesSent = ko.observableArray([]);

        self.jointsToRender = ko.observableArray([]);
        self.framesToDisplay = ko.observableArray([]);

        self.fillCanvasParams = function (canvas, width, height) {
            canvas.fillStyle = 'red';
            canvas.width = width;
            canvas.height = height;
            var canvasCtx = canvas.getContext('2d');

            return { 'canvas': canvas, 'canvasCtx': canvasCtx };
        }

        self.initCanvasByID = function (ID, width, height) {
            var canvas = elemByID(ID);
            self.fillCanvasParams(canvas, width, height);
        }

        self.createCanvas = function (width, height) {
            var canvas = document.createElement('canvas');
            return self.fillCanvasParams(canvas, width, height);
        }


        self.addFrameToQueue = function (queue, base64Image) {
            if (queue.length == self.batchSize()) {
                queue.splice(0, queue.length);
                queue.push(base64Image);
            }
            else {
                queue.push(base64Image);
            }
        }

        self.sendFramesToBeProcessed = function () {
            self.framesSent([]);
            self.framesQueue().forEach(function (frame) {
                self.framesSent.push('data:image/jpeg;base64,' + frame);
            });

            //combine all frames to combine into bigCanvas
            var bigCanvas = vm.createCanvas(EXPECTED_DIM, vm.batchSize() * EXPECTED_DIM);
            for (var i = 0; i < vm.batchSize(); ++i) {
                var frame = self.framesToCombine()[i];
                bigCanvas.canvasCtx.putImageData(frame, 0, i * EXPECTED_DIM);
            }
            bigCanvas.canvasCtx.drawImage(bigCanvas.canvas, 0, 0);

            var bigImageJpeg = bigCanvas.canvas.toDataURL('image/jpeg').split(',')[1];

            bigCanvas.canvas.remove();


            //send image data url to server
            $.post(self.serverURL(),
                JSON.stringify(bigImageJpeg),
                function (response) {

                    if (self.mode() == 'joints') {
                        
                    }
                    else if (self.mode() == 'heatmap') {
                        self.addFramesToDisplay(response, 'heatmap');                        
                    }
                    else if (self.mode() == 'activation_map') {
                        //todo
                    }

                },
                "json")
                .fail(function (response) {
                    self.sendFrames(false);
                    setTimeout(function () {
                        self.sendFrames(true);
                    }, 3000);
                });
        }

        self.addFramesToDisplay = function (imageBatch, mode) {
            var batchCanvas = vm.createCanvas(EXPECTED_DIM, vm.batchSize() * EXPECTED_DIM);
            var largeImage = new Image();
            largeImage.onload = function () {
                batchCanvas.canvasCtx.drawImage(this, 0, 0, EXPECTED_DIM, vm.batchSize() * EXPECTED_DIM);

                for (var i = 0; i < vm.batchSize(); i++) {
                    var segmentedImage = batchCanvas.canvasCtx.getImageData(
                        0, i * EXPECTED_DIM, EXPECTED_DIM, EXPECTED_DIM);
                    vm.framesToDisplay.push(segmentedImage);
                }
            }

            largeImage.src = 'data:image/jpeg;base64,' + imageBatch;
        }

    }

    //custom bindings and helper funcs (ignore)
    ko.bindingHandlers.fadeVisible = {
        init: function (element, valueAccessor) {
            var value = valueAccessor();
            $(element).toggle(ko.utils.unwrapObservable(value));
        },
        update: function (element, valueAccessor) {
            var value = valueAccessor();
            ko.utils.unwrapObservable(value) ? $(element).fadeIn() : $(element).hide();
        }
    };
    //init ko viewmodel
    window.vm = new ProcessStreamVM();
    ko.applyBindings(vm);

    vm.initCanvasByID('heatmap-canvas', EXPECTED_DIM, EXPECTED_DIM);

    function renderHeatmapOverlay() {
        var canvasToDisplay = elemByID('heatmap-canvas');
        var canvasToDisplayCtx = canvasToDisplay.getContext('2d');

        var originalImage = new Image();
        var origCanvas = vm.createCanvas(EXPECTED_DIM, EXPECTED_DIM);
        originalImage.onload = function () {
            origCanvas.canvasCtx.drawImage(this, 0, 0);
        }

        originalImage.src = vm.framesSent()[0];
        var origImgData = canvasToDisplayCtx.getImageData(
            0, 0, EXPECTED_DIM, EXPECTED_DIM);

        var heatmap = vm.framesToDisplay()[0];
        var heatmapData = heatmap.data;
        //remove all pixels that are entirely black
        var data = origImgData.data;
        for (var n = 0; n < (4*EXPECTED_DIM*EXPECTED_DIM); n += 4) {
            data[n + 0] = 0.5*data[n + 0] + 0.5*heatmapData[n + 0];
            data[n + 1] = 0.5*data[n + 1] + 0.5*heatmapData[n + 1];
            data[n + 2] = 0.5*data[n + 2] + 0.5*heatmapData[n + 2];
        }

        origCanvas.canvasCtx.putImageData(origImgData, 0, 0);
        canvasToDisplayCtx.drawImage(origCanvas.canvas, 0, 0);

        origCanvas.canvas.remove()

        vm.framesToDisplay.shift();
        vm.framesSent.shift();
    }

    function eventLoop() {
        if (video.clientHeight == 320) return;

        var videoWidth = video.clientWidth;
        var videoHeight = video.clientHeight;
        var offsetX = (videoWidth - videoHeight) / 2;

        //temporary canvas used to take a screenshot of the video and crop the sides off
        var canvas = vm.createCanvas(EXPECTED_DIM, EXPECTED_DIM);

        //take the screenshot and draw it onto the canvas (positioned to crop the sides)
        canvas.canvasCtx.drawImage(
            video, offsetX, 0, videoWidth - 2 * offsetX, videoHeight,
            0, 0, EXPECTED_DIM, EXPECTED_DIM
        );

        //convert canvas to base64 image, add the frame to the 'framesToSend' array
        var imageJpeg = canvas.canvas.toDataURL('image/jpeg').split(',')[1];
        vm.addFrameToQueue(vm.framesQueue(), imageJpeg);
        vm.addFrameToQueue(vm.framesToCombine(),
            canvas.canvasCtx.getImageData(0, 0, canvas.canvas.width, canvas.canvas.height)
        );

        if (vm.sendFrames() && (vm.framesQueue().length == vm.batchSize())) {
            vm.sendFramesToBeProcessed();
        }

        canvas.canvas.remove();

        if (vm.mode() == 'heatmap') {
            if ((vm.framesToDisplay().length > 0) && (vm.framesSent().length > 0)) {
                renderHeatmapOverlay();
            }
        }
    }

    //webcam capture + eventloop init
    function handleSuccessFact(video) {
        return function (stream) {
            window.stream = stream;
            video.srcObject = stream;
        }
    }

    function handleError(error, video) {
        console.log('navigator.getUserMedia error: ', error);
    }

    $(document).ready(function () {
        var video = $('video')[0];
        var constraints = {
            audio: false,
            video: true
        };

        navigator.mediaDevices.getUserMedia(constraints)
            .then(handleSuccessFact(video))
            .catch(handleError);

        setInterval(eventLoop, 500);
    });
</script>
