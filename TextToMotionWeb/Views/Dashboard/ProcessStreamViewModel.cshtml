<script>
    function elemByID(id) { return document.getElementById(id); }

    var ProcessStreamVM = function () {
        var self = this;

        self.disableSendingOfFrames = ko.observable(false);

        self.mode = ko.observable('joints');
        self.serverURL = ko.computed(function () {
            if (self.mode() == 'joints') return 'https://brendanduke.ca:8765/';
            else if (self.mode() == 'heatmap') return 'https://brendanduke.ca:8765/heatmap';
            else return 'https://brendanduke.ca:8765/activation_map'

        });

        self.batchSize = ko.observable(16);
        self.framesToSend = ko.observableArray([]);
        self.framesThatWereSent = ko.observableArray([]);
        self.framesToDisplay = ko.observableArray([]);
        self.currentFrameToDisplay = ko.observable('/images/placeholders/blurred.jpg');


        self.addFrameToQueue = function (base64Image) {
            if (self.framesToSend().length == self.batchSize()) {
                self.framesToSend.shift();
                self.framesToSend.push(base64Image);
            }
            else self.framesToSend.push(base64Image);
        }


        self.sendFramesToBeProcessed = function () {
            self.framesToSend().forEach(function (frame) {
                self.framesThatWereSent.push('data:image/jpeg;base64,' + frame);
            });

            $.post(self.serverURL(),
                ko.toJSON(self.framesToSend()),
                function (response) {
                    self.disableSendingOfFrames(false);

                    if (self.mode() == 'joints') {


                    }
                    else if (self.mode() == 'heatmap') {
                        response.forEach(function (heatmap) {
                            self.framesToDisplay.push('data:image/jpeg;base64,' + heatmap);
                        });

                    }
                    //based on mode, draw joints onto a canvas OR just display an image

                    /*$.each(jointCoords[0],
                        function (propertyName, value) {
                            var maxDim = Math.max(canvas.width, canvas.height);
                            var x = maxDim * value[0] + canvas.width / 2;
                            var y = maxDim * value[1] + canvas.height / 2;

                            canvasContext.beginPath();
                            var circle = canvasContext.arc(x, y, 10, 0, 2 * Math.PI);
                            canvasContext.fill(circle);
                        });*/
                },
                "json");
        }
    }


    //custom bindings and helper funcs 
    ko.bindingHandlers.fadeVisible = {
        init: function (element, valueAccessor) {
            // Initially set the element to be instantly visible/hidden depending on the value
            var value = valueAccessor();
            $(element).toggle(ko.utils.unwrapObservable(value)); // Use "unwrapObservable" so we can handle values that may or may not be observable
        },
        update: function (element, valueAccessor) {
            // Whenever the value subsequently changes, slowly fade the element in or out
            var value = valueAccessor();
            ko.utils.unwrapObservable(value) ? $(element).fadeIn() : $(element).hide();
        }
    };

    ko.bindingHandlers.fadeVisibleAlt = {
        init: function (element, valueAccessor) {
            // Initially set the element to be instantly visible/hidden depending on the value
            var value = valueAccessor();
            $(element).toggle(ko.utils.unwrapObservable(value)); // Use "unwrapObservable" so we can handle values that may or may not be observable
        },
        update: function (element, valueAccessor) {
            // Whenever the value subsequently changes, slowly fade the element in or out
            var value = valueAccessor();
            ko.utils.unwrapObservable(value) ? $(element).show() : $(element).hide();
        }
    }



    //init
    window.vm = new ProcessStreamVM();
    ko.applyBindings(vm);








    //func defs and main event loop...

    function eventLoop() {
        var video = $('video')[0];
        if (video.clientHeight == 320) return;
        //var canvas = $('canvas')[0];
        var canvas = document.createElement('canvas');
        var canvasContext = canvas.getContext('2d');

        canvas.width = video.clientWidth;
        canvas.height = video.clientHeight;
        canvas.fillStyle = 'red';

        var expectedDim = 384;
        var offsetX = (video.clientWidth - video.clientHeight) / 2;

        canvas.width = expectedDim;
        canvas.height = expectedDim;
        canvasContext.drawImage(
            video, offsetX, 0, video.clientHeight, video.clientHeight,
            0, 0, expectedDim, expectedDim
        );


        var imageJpeg = canvas.toDataURL('image/jpeg').split(',')[1];
        vm.addFrameToQueue(imageJpeg);

        //this if can be updated to have another condition for : !vm.disableSendingOfFrames() -> might come into play when actually rendering the images
        if (!vm.disableSendingOfFrames() && (vm.framesToSend().length == vm.batchSize())) {
            vm.disableSendingOfFrames(true);
            vm.sendFramesToBeProcessed();
        }
        canvas.remove();



        //showing the image preview if mode is heatmap
        if (vm.mode() == 'heatmap') {
            //var originalImageCanvas = document.createElement('canvas');
            var originalImageCanvas = elemByID('original-image-canvas');
            var heatmapCanvas = elemByID('heatmap-only-canvas');
            var heatmapWithImageCanvas = elemByID('heatmap-with-image-canvas');


            originalImageCanvas.width = video.clientWidth;
            originalImageCanvas.height = video.clientHeight;
            heatmapCanvas.width = video.clientWidth;
            heatmapCanvas.height = video.clientHeight;
            heatmapWithImageCanvas.width = video.clientWidth;
            heatmapWithImageCanvas.height = video.clientHeight;
          


            var originalImageContext = originalImageCanvas.getContext('2d');
            var heatmapContext = heatmapCanvas.getContext('2d');
            var heatmapWithImageContext = heatmapWithImageCanvas.getContext('2d');
            


            var destinationOffsetX = (video.clientWidth - expectedDim) / 2;
            var destinationOffsetY = (video.clientHeight - expectedDim) / 2;
            var originalImage = new Image();
            var heatmapImage = new Image();

            originalImage.onload = function () {
                originalImageContext.drawImage(this, 0, 0, video.clientWidth, video.clientHeight,
                    destinationOffsetX, destinationOffsetY, video.clientWidth, video.clientHeight
                );
            }
            heatmapImage.onload = function () {
                heatmapContext.drawImage(this, 0, 0, video.clientWidth, video.clientHeight,
                    destinationOffsetX, destinationOffsetY, video.clientWidth, video.clientHeight
                );


                var heatmapImageData = heatmapContext.getImageData(0, 0, video.clientWidth, video.clientHeight);

                var data = heatmapImageData.data;
                //remove all pixels that are entirely black
                for (var y = 0; y < video.clientHeight; y++) {
                    for (var x = 0; x < video.clientWidth; x++) {
                        var n = ((video.clientWidth * y) + x) * 4;
                        if (data[n] + data[n + 1] + data[n + 2] == 0) {
                            data[n + 3] = 0;
                        }
                    }
                }


                heatmapContext.putImageData(heatmapImageData, 0, 0);
                originalImageContext.drawImage(heatmapCanvas, 0, 0);
                //heatmapToDisplayContext.drawImage(heatmapImageCanvas, 0, 0);


            }

            if (vm.framesToDisplay().length > 1 && vm.framesThatWereSent().length > 1) {
                originalImage.src = vm.framesThatWereSent()[0];
                heatmapImage.src = vm.framesToDisplay()[0];
                
                vm.framesToDisplay.shift();
                vm.framesThatWereSent.shift();
            }
            else {
                originalImage.src = '/images/placeholders/blurred.jpg';
                heatmapImage.src = '/images/placeholders/blurred.jpg';
            }
        }
        

    }




    function handleSuccessFact(video) {
        return function (stream) {
            window.stream = stream;
            video.srcObject = stream;
        }
    }

    function handleError(error, video) {
        console.log('navigator.getUserMedia error: ', error);
    }






    $(document).ready(function () {
        var video = $('video')[0];
        var constraints = {
            audio: false,
            video: true
        };

        navigator.mediaDevices.getUserMedia(constraints)
            .then(handleSuccessFact(video))
            .catch(handleError);


        setInterval(eventLoop, 1000);
    });
</script>